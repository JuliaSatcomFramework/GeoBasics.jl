#= 
This file contains functions to identify and eventually split rings of polyareas that cross the antimeridian.
The code is inspired by the implementation in the python library at https://github.com/gadomski/antimeridian, though it's simplified to only work on a subset of cases for the moment
=#

# Force a specific orientation to a ring
force_orientation(o::OrientationType, r::VALID_RING) = orientation(r) == o ? r : reverse(r)

# Checks if a ring has an antimeridian crossing. This assumes that any segment spanning more than 180° in longitude is crossing the antimeridian
function has_antimeridian(ring::VALID_RING)
    any(segments(ring)) do segment
        p1, p2 = extrema(segment)
        abs(get_lon(p1) - get_lon(p2)) > 180
    end
end

function split_antimeridian(ring::RING_CART{T}, o = orientation(ring)) where T <: AbstractFloat
    ptype = POINT_CART{T}
    segs = Vector{ptype}[]
    seg = ptype[]
    function P(lon, lat)
        to_cart_point(T, (lon, lat))
    end
    δlon(p1, p2) = get_lon(p2) - get_lon(p1)
    for s in segments(ring)
        p1, p2 = extrema(s)
        push!(seg, p1)
        Δlon = δlon(p1, p2)
        if 180 < Δlon < 360 # Crossing from West hemisphere to East hemisphere
            lat = crossing_latitude_flat(p1, p2)
            push!(seg, P(-180, lat))
            push!(segs, seg)
            seg = [P(180, lat)]
        elseif -360 < Δlon < -180 # Crossing from East hemisphere to West hemisphere
            lat = crossing_latitude_flat(p2, p1)
            push!(seg, P(180, lat))
            push!(segs, seg)
            seg = [P(-180, lat)]
        end
    end
    if isempty(segs)
        # We didn't find any antimeridian crossing
        push!(segs, seg)
    else
        # This is slightly different from the python library implementation, but I am not sure what is the python library doing there
        prepend!(first(segs), seg)
    end
    # We always force rings to have the desired orientation
    return map(r -> force_orientation(o, Ring(r)), join_segments!(segs))
end

# This function will process the segments and join segments together if they belong to the same polygon. Considering how the segments were generated (following the algorithm description in https://www.gadom.ski/antimeridian/latest/the-algorithm), one segment must be included inside another if the start/end of the segment are both inside the latitude range of the start/end points of another segment located on the same hemipshere (e.g. they share the same longitude sign). This implementation assumes that the first and last point of each segment are located on the antimeridian line, which should be true for segments generated by the `split_antimeridian` function.
function join_segments!(segs::Vector{Vector{POINT_CART{T}}}) where T <: AbstractFloat
    processed = empty(segs)
    function inclusion_decision(target, candidate)
        tstart, tend = first(target), last(target)
        cstart, cend = first(candidate), last(candidate)
        # If the candidate does not have the same lognitude sign we ignore this candidate
        sign(get_lon(tstart)) == sign(get_lon(cstart)) || return false
        target_Δlat = get_lat(tend) - get_lat(tstart)
        candidate_Δlat = get_lat(cend) - get_lat(cstart)
        # For the candidate to be eligible for inclusion, it must have Δlat which has opposite sign than the target and lower absolute value
        sign(target_Δlat) == -sign(candidate_Δlat) || return 0
        start_Δlat = get_lat(tstart) - get_lat(cstart)
        # We still have to check whether one segment is inside the bounds of the other
        if abs(target_Δlat) > abs(candidate_Δlat)
            abs(start_Δlat) < abs(target_Δlat) ? 1 : 0
        else
            abs(start_Δlat) < abs(candidate_Δlat) ? -1 : 0
        end
    end
    while !isempty(segs)
        target = popfirst!(segs)
        for i in eachindex(segs)
            decision = inclusion_decision(target, segs[i])
            if decision != 0
                candidate = popat!(segs, i)
                if decision < 0
                    target, candidate = candidate, target
                end
                append!(target, candidate)
                break
            end
        end
        push!(processed, target)
    end
    return processed
end


"""
    split_antimeridian(polyareas_vector::Vector{POLY_CART{T}})

Takes as input a vector of `Cartesian2D{WGS84Latest}` `PolyArea`s and process each of them to eventually split antimeridian crossings in each of the rings of the `PolyArea` (both for outer and inner rings, e.g. holes).

It returns a vector of `PolyArea`s where all antimeridian crossings have been handled, potentially resulting in a higher number of elements compared to the input vector (if at least one of the provided `PolyArea`s has antimeridian crossings).

See also [`GeoBorders`](@ref), [`GeoBorders`](@ref), [`polyareas`](@ref), [`bboxes`](@ref), [`FastInGeometry`](@ref).
"""
function split_antimeridian(polyareas_vector::Vector{POLY_CART{T}}) where T <: AbstractFloat
    mapreduce(vcat, polyareas_vector) do poly
        outer, inners... = rings(poly)
        has_antimeridian(outer) || return [poly] # If there is no antimeridian crossing in the outer ring, we simply return a Multi only containing the original polyarea
        # We start by splitting the outer rings of the polyarea
        splitted_outer = split_antimeridian(outer, CCW)
        # For each of the resulting outers
        polyareas = map(r -> PolyArea(r), splitted_outer)
        # We now iterate through all inner rings, checking if they need to split and finding out in which of the splitted polyareas the potentially splitted holes belong to
        for inner in inners
            splitted_inner = split_antimeridian(inner, CW)
            # We now iterate through all the splitted outers, checking if the inner ring belongs to it
            for r in splitted_inner
                # We only check inclusion of the first point of the ring
                p = vertex(r, 1)
                placed = false
                for this_poly in polyareas
                    if in(p, this_poly)
                        push!(this_poly.rings, r)
                        placed = true
                        break
                    end
                end
                placed || error("Something went wrong, one of the inner rings could not be placed into any of the splitted polyareas")
            end
        end
        polyareas
    end
end

# function split_antimeridian(geometry)
#     polyareas_cart = polyareas(Cartesian, geometry) |> collect
#     multi_cart = split_antimeridian(polyareas_cart)
#     if crs(geometry) <: Cartesian
#         return multi_cart
#     else
#         latlon_geometry(multi_cart)
#     end
# end