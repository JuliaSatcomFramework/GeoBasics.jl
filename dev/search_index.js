var documenterSearchIndex = {"docs":
[{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"public/#GeoBasics.FastInGeometry","page":"Public API","title":"GeoBasics.FastInGeometry","text":"FastInGeometry{T} <: Geometry{🌐,LATLON{T}}\n\nAbstract type identifying geometries over Earth's surface where a fast custom algorithm for checking point inclusion is available. \n\nThis package define a single concrete subtype GeoBorders. Custom subtypes in downstream packages should in most cases contain a field with GeoBorders type.\n\nExtended Help\n\nType Parameter\n\nThe type parameter T represents the machine precision of the underlying coordinates and is expected to be a subtype of AbstractFloat for the public API. This is in line with the public API of Meshes.jl and CoordRefSystems.jl that this package heavily relies on.\n\nFast Inclusion Algorithm\n\nThe fast inclusion algorithm is quite simple and relies on having a bounding box defined for each polygon part of the FastInGeometry. The custom inclusion algorithm simply iterates through all polygons and prefilter points by checking inclusion in the bounding box (which is an almost free operation). This can have significant speed ups especially if the polygons have a lot of points.\n\nFor subtypes if FastInGeometry, the following methods are added to exploit the fast inclusion algorithm by default:\n\nBase.in(p::VALID_POINT, g::FastInType)\nBase.in(p::LATLON, g::FastInType)\n\nwhere VALID_POINT, LATLON and FastInType are type aliases defined (but not exported) in the package.\n\nInterface\n\nFor custom subtypes of FastInGeometry that do not contain a field that is a subtype of GeoBorders, the following methods are expected to be implemented:\n\ngeoborders: This should return the GeoBorders instance associated to the input. If this method is implemented, all the others are not strictly needed\npolyareas: This should return an iterable of PolyArea instances contained in the custom geometry. \nbboxes: This should return an iterable of Box instances representing the boundingboxes of each PolyArea returned by polyareas.\n\nSee the docstrings of the respective methods for more details.\n\n\n\n\n\n","category":"type"},{"location":"public/#GeoBasics.GeoBorders","page":"Public API","title":"GeoBasics.GeoBorders","text":"GeoBorders{T} <: FastInGeometry{T}\n\nBasic geometry used to represent borders of countries/regions on Earth's surface, supporting a fast algorithm for checking point inclusion.\n\nThe polygons contained within a GeoBorders object are expected to satisfy the following two conditions (mainly in line with the GeoJSON standard):\n\nThe polygons must not cross the antimeridian (the 180° latitude line). If a polygon should encompass a region crossing the antimeridian, it shall be split into multiple polygons.\nEach polygon must have its exterior/outer ring following a counter-clockwise orientation, and all of its interior rings (holes) having a clockwise orientation.\n\nThe parametric type T represent the machine precision of the underlying coordinates and should be a subtype of AbstractFloat.\n\nConstructors\n\nGeoBorders{T}(inp; fix_antimeridian_crossing)\nGeoBorders(inp; fix_antimeridian_crossing)\n\nTake an input object which can be a Geometry, Domain or a Vector (of geometries) and returns the GeoBorders instance containing all the polyareas contained in the provided object, optionally forcing the machine precision of all underlying coordinates to T <: AbstractFloat\n\nFor input geometries of the following plain types from Meshes.jl:\n\nMulti\nPolyArea\nBox\n\nthe constructor will ensure the two conditions specified above, by eventually fixing both antimeridian crossings and ensuring correct orientation of polygons rings.\n\nFor input geometries that are already satisfying the FastInGeometry interface, the constructor will simply extract the polyareas assuming they are already in a correct form.\n\nThe fix_antimeridian_crossing keyword argument is only respected for plain Meshes geometries and can be set to false to disable fixing the antimeridian crossing by splitting polygons. This can be useful in some cases where polygons are purposedly made of long segments (spanning more than 180° of longitude) which would otherwise be split into multiple polyareas.\n\nWhen the input is a single Geometry or Domain, the type parameter T can be omitted from the constructor and will be inferred using valuetype(input). When using a vector of geometries as input to the function, the machine precision T must be provided explicitly.\n\nnote: Note\nThe GeoBorders constructor will remove duplicate polyareas if any are present in the input polyareas after processing.\n\nSee also FastInGeometry, polyareas, bboxes, geoborders.\n\n\n\n\n\n","category":"type"},{"location":"public/#Interface-Functions","page":"Public API","title":"Interface Functions","text":"","category":"section"},{"location":"public/#GeoBasics.geoborders","page":"Public API","title":"GeoBasics.geoborders","text":"geoborders(geom)\n\nExtract the Geo borders of the region/geometry provided as input. \n\nThis function expects the output to be an instance of the GeoBorders type.\n\nBy default, this function will try to extract the first field in the given type whose type is GeoBorders, so custom types do not need to add a method for this function explicitly if they do have a field that satisfies field isa GeoBorders.\n\nHaving a valid method of this function for custom geometries is sufficient to satisfy the FastInGeometry interface, as polyareas and bboxes have a default fallback which exploit this method.\n\nSee also polyareas, bboxes, FastInGeometry, to_multi.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.polyareas","page":"Public API","title":"GeoBasics.polyareas","text":"polyareas(crs, geom)\npolyareas(crs)\n\nReturns an iterable of the 2D PolyAreas associated to the input geometry defined over the Earth's surface.\n\nnote: Note\nThe PolyArea objects returned by this function are expected to represent polygons which never cross the antimeridian line (if a polygon is expected to cross the antimeridian line, it should be split into separate polygons divided at the antimeridian line). See the documentation of the package for more details.\n\nArguments\n\ncrs::Union{Type{LatLon}, Type{Cartesian}}: Specifies whether the returned vector of PolyArea elements should have LatLon{WGS84LatLon} or Cartesian2D{WGS84Latest} as underlying CRS.\ngeom: The input geometry. \n\nWhen only the crs argument is provided, the function simply returns Base.Fix1(polyareas, crs).\n\nSee also geoborders, bboxes, FastInGeometry, to_multi.\n\nExtended Help\n\nWhen implementing the FastInGeometry interface for types where geoborders does not return a valid GeoBorders object (or for which a custom implementation of polyareas is preferred), one should implement the following two methods:\n\npolyareas(::Type{Cartesian}, custom_geom)\npolyareas(::Type{LatLon}, custom_geom)\n\nnote: Note\nTo ensure optimal speed for the inclusion algorithm, it is recommended that this function returns a pre-computed iterable of PolyAreas rather than computing it at runtime, at least for the method with Cartesian as crs as that is used by the fast point inclusion algorithm.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.bboxes","page":"Public API","title":"GeoBasics.bboxes","text":"bboxes(crs, geom)\nbboxes(crs)\n\nReturns an iterable of the 2D Boxs associated to the input geometry defined over the Earth's surface. \n\nnote: Note\nEach of the Box in the returned iterable is expected to be tied 1 to 1 to the PolyAreas returned by polyareas for the same input geometry and represents the PolyArea's bounding box (as returned by Meshes.boundingbox(poly)).\n\nArguments\n\ncrs::Union{Type{LatLon}, Type{Cartesian}}: Specifies whether the returned vector of Box elements should have LatLon{WGS84LatLon} or Cartesian2D{WGS84Latest} as underlying CRS.\ngeom: The input geometry.\n\nWhen only the crs argument is provided, the function simply returns Base.Fix1(bboxes, crs).\n\nSee also geoborders, polyareas, FastInGeometry.\n\nExtended Help\n\nWhen implementing the FastInGeometry interface for types where geoborders does not return a valid GeoBorders object (or for which a custom implementation of bboxes is preferred), one should implement the following two methods:\n\nbboxes(::Type{Cartesian}, custom_geom)\nbboxes(::Type{LatLon}, custom_geom)\n\nnote: Note\nTo ensure optimal speed for the inclusion algorithm, it is recommended that this function returns a pre-computed iterable of Boxs rather than computing it at runtime, at least for the method with Cartesian as crs as that is used by the fast point inclusion algorithm.\n\n\n\n\n\n","category":"function"},{"location":"public/#Helpers","page":"Public API","title":"Helpers","text":"","category":"section"},{"location":"public/#GeoBasics.to_multi","page":"Public API","title":"GeoBasics.to_multi","text":"to_multi(crs, geom)\nto_multi(crs)\n\nReturns a Multi object containing the PolyAreas associated to the input geometry and returned by calling polyareas(crs, geom).\n\nWhen called with just the crs type as argument, it simply returns Base.Fix1(to_multi, crs).\n\nThis is intended to simplify the generation of a plain Multi object for further processing using standard functions from Meshes.jl.\n\nGeoBasics explicitly avoids extending methods from Meshes.jl on FastInGeometry objects to encourage users to explicitly decide whether to use the LatLon or Cartesian CRS instead of magically taking a decision on their behalf.\n\nnote: Note\nThe computational cost of this function for types which have a valid method for geoborders is almost free (~1-2 nanoseconds).\n\nSee also geoborders, polyareas, bboxes, FastInGeometry. \n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.to_cart_point","page":"Public API","title":"GeoBasics.to_cart_point","text":"to_cart_point(T::Type{<:AbstractFloat}, obj)\nto_cart_point(T::Type{<:AbstractFloat})\nto_cart_point(obj)\n\nExtracts the lat/lon coordinates associated to input obj and return them as a Point from Meshes with Cartesian2D{WGS84Latest} as CRS and optionally forcing the underlying machine precision of the coordinates to T.\n\nThe second method simply returns Base.Fix1(to_cart_point, T).\n\nThe third method, will try to extract the machine precision from obj by calling BasicTypes.valuetype(obj).\n\nnote: Note\nThis function exploits GeoPlottingHelpers.to_row_lonlat internally so any object that has a valid method for to_row_lonlat will work as input.\n\nExamples\n\njulia> using GeoBasics\n\njulia> to_cart_point(Float32, (10, 20)) # Force precision to `Float32`\nPoint with Cartesian{WGS84Latest} coordinates\n├─ x: 10.0f0 m\n└─ y: 20.0f0 m\n\njulia> to_cart_point(LatLon(20,10)) # Extract precision from `LatLon` input\nPoint with Cartesian{WGS84Latest} coordinates\n├─ x: 10.0 m\n└─ y: 20.0 m\n\nSee also to_latlon_point.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.to_latlon_point","page":"Public API","title":"GeoBasics.to_latlon_point","text":"to_latlon_point(T::Type{<:AbstractFloat}, obj)\nto_latlon_point(T::Type{<:AbstractFloat})\nto_latlon_point(obj)\n\nExtracts the lat/lon coordinates associated to input obj and return them as a Point from Meshes with LatLon{WGS84Latest} as CRS and optionally forcing the underlying machine precision of the coordinates to T.\n\nThe second method simply returns Base.Fix1(to_latlon_point, T).\n\nThe third method, will try to extract the machine precision from obj by calling BasicTypes.valuetype(obj).\n\nnote: Note\nThis function exploits GeoPlottingHelpers.to_row_lonlat internally so any object that has a valid method for to_row_lonlat will work as input.\n\nExamples\n\njulia> using GeoBasics\n\njulia> to_latlon_point(Float32, (10, 20)) # Force precision to `Float32`\nPoint with GeodeticLatLon{WGS84Latest} coordinates\n├─ lat: 20.0f0°\n└─ lon: 10.0f0°\n\njulia> to_latlon_point(LatLon(20,10)) # Extract precision from `LatLon` input\nPoint with GeodeticLatLon{WGS84Latest} coordinates\n├─ lat: 20.0°\n└─ lon: 10.0°\n\nSee also to_cart_point.\n\n\n\n\n\n","category":"function"},{"location":"#GeoBasics","page":"Home","title":"GeoBasics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides fundamental building blocks for geographic operations, specifically designed for downstream packages in the JuliaSatcomFramework ecosystem. It builds open the JuliaEarth ecosystem and specifically heavily relies on Meshes.jl and CoordRefSystems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It mainly addresses two desired functionalities in our downstream packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplifying a way to create custom types representing regions/geometries which have an optimized algorithm for check point inclusion (within the region)\nThis is achieved by subtyping the FastInGeometry abstract type and implementing its limited interface\nAvoiding issues with regions created from polygons that might cross the antimeridian (the line where longitude is ±180°). \nThis is handled in the constructor of GeoBorders, the only concrete type implementing the FastInGeometry interface exposed by this package. \nThe algorithm to fix antimeridian crossing is based on the algorithm implemented in the python package antimeridian that also provides a simplified explanation of the algorithm in its documentation.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Point-inclusion-algorithm","page":"Tutorial","title":"Point inclusion algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package was born from the need of ensuring a simple way of optimizing the performance of checking whether a point on the Earth's surface is located within a given region (e.g. a country, a satellite beam, or any other area that can be represented by a polygon in latitude/longitude coordinates).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need to define multiple types of such regions in our downstream packages (e.g. CountriesBorders.jl) and we want to minimize code duplication as much as possible.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The traditional p in region is well defined in Meshes.jl but is suboptimal when one wants to check a lot of points (e.g. thousands) over a domain spanning multiple polygons (e.g. the domain of all polygons associated to all countries). The complexity of checking for point inclusion in a polygon increases with the number of points in the polygon, and when you have lots of points and lots of polygons, most of your point/polygon pair will return false.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The approach to speed up computations taken in this package is to create custom geometries that store not only the polyareas but also the bounding boxes (i.e. a Box from Meshes.jl) associated to each polyarea.  The modified inclusion algorithm then simply prefilters point/polygon pairs by checking first inclusion in the bounding box (which is extremely fast) and falling back to checkin inclusion in the polygon only if p in bbox is true. This has shown to provide speed ups of 20x-40x in tests when implemented for the CountriesBorders.jl downstream package (see this PR)","category":"page"},{"location":"tutorial/#FastInGeometry-Interface","page":"Tutorial","title":"FastInGeometry Interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To simplify exploiting this fast algorithm for custom geometries defined in downstream packages, this package defines an interface that is adhered to when a type satisfies the three conditions below:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It subtypes the FastInGeometry abstract type defined and exported by this package\nIt has a valid method for the interface function polyareas returning an iterable of PolyAreas.\nIt has a valid method for the interface function bboxes returning an iterable of Boxs","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In reality, the 2nd and 3rd conditions can also be met by simply containing a field which subtypes GeoBorders (more details in the next section) or defining a custom method for the interface function geoborders that returns an instance of type GeoBorders.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, see the following code snippet defining a simple geometry that satisfies the FastInGeometry interface by resorting to the simplest approach of having a field subtyping GeoBorders","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeoBasics\n\n# Define a custom type which subtypes \nstruct SimpleGeometry{Float64} <: FastInGeometry{Float64}\n    name::String\n    borders::GeoBorders{Float64}\nend","category":"page"},{"location":"tutorial/#GeoBorders","page":"Tutorial","title":"GeoBorders","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package defines a single concrete subtype satisfying the FastInGeometry interface with the GeoBorders type. This is intended to represent the borders of arbitrary regions, and provides an easy way for custom regions to adhere to the FastInGeometry interface (as explained above).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Additionally, when provided with geometries that are plain Multi, PolyArea or Box from Meshes (and not other geometries satysfiying the FastInGeometry interface), the constructor for GeoBorders automatically tries fixing issues with polygons crossing the antimeridian line. It does so by implementing the algorithm of the antimeridian python library that also provides a simplified explanation of the algorithm in its documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To show the problem of with polygons crossing the antimeridian, consider the following complex polygon that contains holes and crosses the antimeridian multiple times","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeoBasics\nusing GeoBasics.Meshes\nusing GeoBasics.GeoPlottingHelpers\nusing PlotlyBase\nusing PlotlyDocumenter\n\ncomplex_s_poly = let\n    f = Base.Fix1(to_cart_point, Float64)\n    outer = map(f, [ # Exterior part of the polygon, crossing the antimeridian multiple times\n        (160,30),\n        (-160,30),\n        (-160,0),\n        (170, 0),\n        (170, -10),\n        (-160, -10),\n        (-160, -20),\n        (160, -20),\n        (160, 10),\n        (-170, 10),\n        (-170, 20),\n        (160, 20),\n    ]) |> Ring\n    inner_west = map(f, [ # Hole in the western hemisphere, in the lower right of the polygon\n        (-162, -12),\n        (-162, -18),\n        (-168, -18), \n        (-168, -12)\n    ]) |> Ring\n    inner_east = map(f, [ # Hole in the eastern hemisphere, in the upper left of the polygon\n        (162, 22),\n        (162, 28),\n        (168, 28), \n        (168, 22)\n    ]) |> Ring\n    inner_both = map(f, [ # Hole crossing the antimeridian, in the middle of the polygon\n        (170, 2),\n        (170, 8),\n        (-170, 8), \n        (-170, 2)\n    ]) |> Ring\n    PolyArea([outer, inner_west, inner_east, inner_both])\nend\n\nplt = with_settings(:OVERSAMPLE_LINES => :SHORT) do # This makes sure that the plot uses the shortest line between points\n    data = geo_plotly_trace(complex_s_poly)\n    Plot(data, Layout(;\n      geo = attr(; \n        center_lon = 180,\n        lonaxis_range = [0, 360]\n      )\n    ))\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In reality, the polygon looks fine because we forced the plot to use shortest line between points for plotting (thus crossing the antimeridian). The actual polygon defined with those coordinates represents instead the following degenerate region:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line\n    data = geo_plotly_trace(complex_s_poly)\n    Plot(data)\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which can also be verified by checking point inclusion of one point that shouldn't be inside but is, and of one that should be in but isn't:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# We use cartesian point as point inclusion in LatLon is not always defined in Meshes\nshould_not = to_cart_point(LatLon(25, 0)) # This is in africa and shouldn't be in the intended polygon\nshould_be = to_cart_point(LatLon(25, 180)) # This is in the ocean inside the polygon and outside it's holes\n\nmap(in(complex_s_poly), (;should_be, should_not))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By feeding this polygon into the constructor of GeoBorders, the antimeridian crossin is handled by splitting the input polygon into 4 subpolygons whenever a crossing of the antimeridian is encountered:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gb = GeoBorders(complex_s_poly)\nplt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line, showing that GeoBorders handle this correctly\n    data = geo_plotly_trace(gb)\n    Plot(data, Layout(;\n      geo = attr(; \n        center_lon = 180,\n        lonaxis_range = [0, 360]\n      )\n    ))\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And checking again for point inclusion we find the expected behavior (including a point in the hole not being considered inside).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"inside_hole = LatLon(25, 165) # Notice that this does not need to be a Point\n\nmap(in(gb), (; should_be, should_not, inside_hole))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As seen from the last example, there is one additional advantage to satisfying the FastInGeometry interface. Inclusion in a FastInRegion does not need to use points which are of Point type with the exact same CRS as the geometry (as in plain Meshes) but can be:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a Point with either LatLon{WGS84Latest} or Cartesian2D{WGS84Latest} CRS,\na plain LatLon{WGS84Latest} coordinate.","category":"page"},{"location":"tutorial/#Override-antimeridian-fix","page":"Tutorial","title":"Override antimeridian fix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The procedure in the GeoBorders constructor that fixes the antimeridian crossing decides if there is one by simply checking if any segment of a polygon spans more than 180° degrees of longitude.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In some cases, this has the unintended consequence of modifying the intended polygon. Consider for example a rectangular polygon going from -100 to +100 longitude and from -20 to + 20 latitude. Creating a GeoBorders with this input polygon will uncorrectly split it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"large_rectangle = let\n  f = to_latlon_point(Float64)\n  PolyArea(map(f, [\n    LatLon(-20, -100),\n    LatLon(-20, 100),\n    LatLon(20, 100),\n    LatLon(20, -100),\n  ]))\nend\n\nplt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line\n    data = geo_plotly_trace(GeoBorders(large_rectangle))\n    Plot(data)\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In these cases, it is possible to override this behavior by using the fix_antimeridian_crossing keyword argument:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line\n    data = geo_plotly_trace(GeoBorders(large_rectangle; fix_antimeridian_crossing = false))\n    Plot(data)\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThe fix_antimeridian_crossing keyword argument is only respected for input geometries which are not already implementing the FastInGeometry interface. As mentioned in the polyareas docstrings, the polygons of FastInGeometry are already assumed to be correct","category":"page"}]
}
