var documenterSearchIndex = {"docs":
[{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/#Types","page":"Public API","title":"Types","text":"","category":"section"},{"location":"public/#GeoBasics.FastInGeometry","page":"Public API","title":"GeoBasics.FastInGeometry","text":"FastInGeometry{T} <: Geometry{🌐, LatLon{WGS84Latest,Deg{T}}}\n\nAbstract type identifying geometries over Earth's surface where a fast custom algorithm for checking point inclusion is available. \n\nThis package define a single concrete subtype GeoBorders. Custom subtypes in downstream packages should in most cases contain a field with GeoBorders type.\n\nExtended Help\n\nType Parameter\n\nThe type parameter T represents the machine precision of the underlying coordinates and is expected to be a subtype of AbstractFloat for the public API. This is in line with the public API of Meshes.jl and CoordRefSystems.jl that this package heavily relies on.\n\nFast Inclusion Algorithm\n\nThe fast inclusion algorithm is quite simple and relies on having a bounding box defined for each polygon part of the FastInGeometry. The custom inclusion algorithm simply iterates through all polygons and prefilter points by checking inclusion in the bounding box (which is an almost free operation). This can have significant speed ups especially if the polygons have a lot of points.\n\nThe following methods are added to Base.in to exploit the fast inclusion algorithm for custom subtypes adhering to the FastInGeometry (or FastInDomain) interface:\n\nBase.in(p, x::FastInGeometry)\nBase.in(p, x::VALID_DOMAINS)\n\nnote: Input Types\nThe point p provided as input is internally converted to within the function by using to_cartesian_point(valuetype(x), p), so custom types representing points on the Earth's surface can also be used with Base.in by having a valid method for to_cartesian_point or to GeoPlottingHelpers.to_raw_lonlat which the former falls back to.The VALID_DOMAINS type alias encompasses FastInDomain, GeometrySet with FastInGeometry elements and SubDomains of either of the previous domains.\n\nInterface\n\nFor custom subtypes of FastInGeometry that do not contain a field that is a subtype of GeoBorders, the following methods are expected to be implemented:\n\ngeoborders: This should return the GeoBorders instance associated to the input. If this method is implemented, all the others are not strictly needed\npolyareas: This should return an iterable of PolyArea instances contained in the custom geometry. \nbboxes: This should return an iterable of Box instances representing the boundingboxes of each PolyArea returned by polyareas.\n\nSee the docstrings of the respective methods for more details.\n\n\n\n\n\n","category":"type"},{"location":"public/#GeoBasics.GeoBorders","page":"Public API","title":"GeoBasics.GeoBorders","text":"GeoBorders{T} <: FastInGeometry{T}\n\nBasic geometry used to represent borders of countries/regions on Earth's surface, supporting a fast algorithm for checking point inclusion.\n\nThe polygons contained within a GeoBorders object are expected to satisfy the following two conditions (mainly in line with the GeoJSON standard):\n\nThe polygons must not cross the antimeridian (the 180° latitude line). If a polygon should encompass a region crossing the antimeridian, it shall be split into multiple polygons.\nEach polygon must have its exterior/outer ring following a counter-clockwise orientation, and all of its interior rings (holes) having a clockwise orientation.\n\nThe parametric type T represent the machine precision of the underlying coordinates and should be a subtype of AbstractFloat.\n\nConstructors\n\nGeoBorders{T}(inp; fix_antimeridian_crossing)\nGeoBorders(inp; fix_antimeridian_crossing)\n\nTake an input object which can be a Geometry, Domain or a Vector (of geometries) and returns the GeoBorders instance containing all the polyareas contained in the provided object, optionally forcing the machine precision of all underlying coordinates to T <: AbstractFloat\n\nFor input geometries of the following plain types from Meshes.jl:\n\nMulti\nPolyArea\nBox\n\nthe constructor will ensure the two conditions specified above, by eventually fixing both antimeridian crossings and ensuring correct orientation of polygons rings.\n\nFor input geometries that are already satisfying the FastInGeometry interface, the constructor will simply extract the polyareas assuming they are already in a correct form.\n\nThe fix_antimeridian_crossing keyword argument is only respected for plain Meshes geometries and can be set to false to disable fixing the antimeridian crossing by splitting polygons. This can be useful in some cases where polygons are purposedly made of long segments (spanning more than 180° of longitude) which would otherwise be split into multiple polyareas.\n\nWhen the input is a single Geometry or Domain, the type parameter T can be omitted from the constructor and will be inferred using valuetype(input). When using a vector of geometries as input to the function, the machine precision T must be provided explicitly.\n\nnote: Note\nThe GeoBorders constructor will remove duplicate polyareas if any are present in the input polyareas after processing.\n\nSee also FastInGeometry, polyareas, bboxes, geoborders.\n\n\n\n\n\n","category":"type"},{"location":"public/#GeoBasics.FastInDomain","page":"Public API","title":"GeoBasics.FastInDomain","text":"FastInDomain{T} <: Domain{🌐, LatLon{WGS84Latest, Deg{T}}}\n\nAbstract type representing a domain of FastInGeometry{T} geometries.\n\nThis type can be subtypes by custom types that represent domains and want to participate in the FastInGeometry interface for fast point inclusion.\n\nSee also: FastInGeometry, to_gset\n\nExtended Help\n\nType Parameter\n\nThe type parameter T represents the machine precision of the underlying coordinates and is expected to be a subtype of AbstractFloat for the public API. This is in line with the public API of Meshes.jl and CoordRefSystems.jl that this package heavily relies on.\n\nFast Inclusion Algorithm\n\nThe fast inclusion algorithm is quite simple and relies on having a bounding box defined for each polygon part of the FastInGeometry. The custom inclusion algorithm simply iterates through all polygons and prefilter points by checking inclusion in the bounding box (which is an almost free operation). This can have significant speed ups especially if the polygons have a lot of points.\n\nThe following methods are added to Base.in to exploit the fast inclusion algorithm for custom subtypes adhering to the FastInGeometry (or FastInDomain) interface:\n\nBase.in(p, x::FastInGeometry)\nBase.in(p, x::VALID_DOMAINS)\n\nnote: Input Types\nThe point p provided as input is internally converted to within the function by using to_cartesian_point(valuetype(x), p), so custom types representing points on the Earth's surface can also be used with Base.in by having a valid method for to_cartesian_point or to GeoPlottingHelpers.to_raw_lonlat which the former falls back to.The VALID_DOMAINS type alias encompasses FastInDomain, GeometrySet with FastInGeometry elements and SubDomains of either of the previous domains.\n\nInterface\n\nTo properly work for fast point inclusion, the custom subtypes of FastInDomain need as a minimum to add valid methods to the following two functions from Meshes.jl:\n\nMeshes.nelements(custom_domain): This should return the number of geometries within the domain\nMeshes.element(custom_domain, ind): This should return the ind-th geometry from the domain\n\n\n\n\n\n","category":"type"},{"location":"public/#Interface-Functions","page":"Public API","title":"Interface Functions","text":"","category":"section"},{"location":"public/#GeoBasics.geoborders","page":"Public API","title":"GeoBasics.geoborders","text":"geoborders(geom)\n\nExtract the Geo borders of the region/geometry provided as input. \n\nThis function expects the output to be an instance of the GeoBorders type.\n\nBy default, this function will try to extract the first field in the given type whose type is GeoBorders, so custom types do not need to add a method for this function explicitly if they do have a field that satisfies field isa GeoBorders.\n\nHaving a valid method of this function for custom geometries is sufficient to satisfy the FastInGeometry interface, as polyareas and bboxes have a default fallback which exploit this method.\n\nSee also polyareas, bboxes, FastInGeometry, to_multi.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.polyareas","page":"Public API","title":"GeoBasics.polyareas","text":"polyareas(crs, geom)\npolyareas(crs)\n\nReturns an iterable of the 2D PolyAreas associated to the input geometry defined over the Earth's surface.\n\nnote: Antimeridian\nThe PolyArea objects returned by this function are expected to represent polygons which never cross the antimeridian line (if a polygon is expected to cross the antimeridian line, it should be split into separate polygons divided at the antimeridian line). See the documentation of the package for more details.\n\nArguments\n\ncrs::Union{Type{LatLon}, Type{Cartesian}}: Specifies whether the returned vector of PolyArea elements should have LatLon{WGS84LatLon} or Cartesian2D{WGS84Latest} as underlying CRS.\ngeom: The input geometry. \n\nWhen only the crs argument is provided, the function simply returns Base.Fix1(polyareas, crs).\n\nSee also geoborders, bboxes, FastInGeometry, to_multi.\n\nExtended Help\n\nWhen implementing the FastInGeometry interface for types where geoborders does not return a valid GeoBorders object (or for which a custom implementation of polyareas is preferred), one should implement the following two methods:\n\npolyareas(::Type{Cartesian}, custom_geom)\npolyareas(::Type{LatLon}, custom_geom)\n\nnote: Performance\nTo ensure optimal speed for the inclusion algorithm, it is recommended that this function returns a pre-computed iterable of PolyAreas rather than computing it at runtime, at least for the method with Cartesian as crs as that is used by the fast point inclusion algorithm.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.bboxes","page":"Public API","title":"GeoBasics.bboxes","text":"bboxes(crs, geom)\nbboxes(crs)\n\nReturns an iterable of the 2D Boxs associated to the input geometry defined over the Earth's surface. \n\nnote: Note\nEach of the Box in the returned iterable is expected to be tied 1 to 1 to the PolyAreas returned by polyareas for the same input geometry and represents the PolyArea's bounding box (as returned by Meshes.boundingbox(poly)).\n\nArguments\n\ncrs::Union{Type{LatLon}, Type{Cartesian}}: Specifies whether the returned vector of Box elements should have LatLon{WGS84LatLon} or Cartesian2D{WGS84Latest} as underlying CRS.\ngeom: The input geometry.\n\nWhen only the crs argument is provided, the function simply returns Base.Fix1(bboxes, crs).\n\nSee also geoborders, polyareas, FastInGeometry.\n\nExtended Help\n\nWhen implementing the FastInGeometry interface for types where geoborders does not return a valid GeoBorders object (or for which a custom implementation of bboxes is preferred), one should implement the following two methods:\n\nbboxes(::Type{Cartesian}, custom_geom)\nbboxes(::Type{LatLon}, custom_geom)\n\nnote: Performance\nTo ensure optimal speed for the inclusion algorithm, it is recommended that this function returns a pre-computed iterable of Boxs rather than computing it at runtime, at least for the method with Cartesian as crs as that is used by the fast point inclusion algorithm.\n\n\n\n\n\n","category":"function"},{"location":"public/#Helpers","page":"Public API","title":"Helpers","text":"","category":"section"},{"location":"public/#GeoBasics.to_multi","page":"Public API","title":"GeoBasics.to_multi","text":"to_multi(crs, geom)\nto_multi(crs)\n\nReturns a Multi object containing the PolyAreas associated to the input geometry and returned by calling polyareas(crs, geom).\n\nWhen called with just the crs type as argument, it simply returns Base.Fix1(to_multi, crs).\n\nThis is intended to simplify the generation of a plain Multi object for further processing using standard functions from Meshes.jl.\n\nGeoBasics explicitly avoids extending methods from Meshes.jl on FastInGeometry objects to encourage users to explicitly decide whether to use the LatLon or Cartesian CRS instead of magically taking a decision on their behalf.\n\nnote: Performance\nThe computational cost of this function for types which have a valid method for geoborders is almost free (~1-2 nanoseconds).\n\nSee also geoborders, polyareas, bboxes, FastInGeometry. \n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.to_gset","page":"Public API","title":"GeoBasics.to_gset","text":"to_gset(crs, dmn)\nto_gset(crs)\n\nReturns a GeometrySet object containing the PolyAreas associated to the input domain and returned by concatenating the output of polyareas(crs, geom) for each geometry geom in the input domain dmn.\n\nWhen called with just the crs type as argument, it simply returns Base.Fix1(to_gset, crs).\n\nThis is intended to simplify the generation of a plain GeometrySet object of the desired CRS for further processing using standard functions from Meshes.jl. It is the parallel of to_multi for domains rather than geometries.\n\nGeoBasics explicitly avoids extending methods from Meshes.jl on domains of FastInGeometry objects to encourage users to explicitly decide whether to use the LatLon or Cartesian CRS instead of magically taking a decision on their behalf.\n\nSee also to_multi, polyareas, bboxes, FastInGeometry. \n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.to_cartesian_point","page":"Public API","title":"GeoBasics.to_cartesian_point","text":"to_cartesian_point(T::Type{<:AbstractFloat}, obj)\nto_cartesian_point(T::Type{<:AbstractFloat})\nto_cartesian_point(obj)\n\nExtracts the lat/lon coordinates associated to input obj and return them as a Point from Meshes with Cartesian2D{WGS84Latest} as CRS and optionally forcing the underlying machine precision of the coordinates to T.\n\nThe second method simply returns Base.Fix1(to_cartesian_point, T).\n\nThe third method, will try to extract the machine precision from obj by calling BasicTypes.valuetype(obj).\n\nnote: Note\nThis function exploits GeoPlottingHelpers.to_row_lonlat internally so any object that has a valid method for to_row_lonlat will work as input.\n\nExamples\n\njulia> using GeoBasics\n\njulia> to_cartesian_point(Float32, (10, 20)) # Force precision to `Float32`\nPoint with Cartesian{WGS84Latest} coordinates\n├─ x: 10.0f0 m\n└─ y: 20.0f0 m\n\njulia> to_cartesian_point(LatLon(20,10)) # Extract precision from `LatLon` input\nPoint with Cartesian{WGS84Latest} coordinates\n├─ x: 10.0 m\n└─ y: 20.0 m\n\nSee also to_latlon_point, to_point.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.to_latlon_point","page":"Public API","title":"GeoBasics.to_latlon_point","text":"to_latlon_point(T::Type{<:AbstractFloat}, obj)\nto_latlon_point(T::Type{<:AbstractFloat})\nto_latlon_point(obj)\n\nExtracts the lat/lon coordinates associated to input obj and return them as a Point from Meshes with LatLon{WGS84Latest} as CRS and optionally forcing the underlying machine precision of the coordinates to T.\n\nThe second method simply returns Base.Fix1(to_latlon_point, T).\n\nThe third method, will try to extract the machine precision from obj by calling BasicTypes.valuetype(obj).\n\nnote: Note\nThis function exploits GeoPlottingHelpers.to_row_lonlat internally so any object that has a valid method for to_row_lonlat will work as input.\n\nExamples\n\njulia> using GeoBasics\n\njulia> to_latlon_point(Float32, (10, 20)) # Force precision to `Float32`\nPoint with GeodeticLatLon{WGS84Latest} coordinates\n├─ lat: 20.0f0°\n└─ lon: 10.0f0°\n\njulia> to_latlon_point(LatLon(20,10)) # Extract precision from `LatLon` input\nPoint with GeodeticLatLon{WGS84Latest} coordinates\n├─ lat: 20.0°\n└─ lon: 10.0°\n\nSee also to_cartesian_point, to_point.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.to_point","page":"Public API","title":"GeoBasics.to_point","text":"to_point(crs::VALID_CRS)\nto_point(crs::VALID_CRS, args...)\n\nConvenience method to call either to_cartesian_point or to_latlon_point depending on the input CRS (either LatLon or Cartesian).\n\nThe first method simply returns the specific function depending on the CRS provided\n\nThe second method will forward the extra args... to the specfic function based on the CRS provided as first argument.\n\nSee also to_cartesian_point, to_latlon_point.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.get_lat","page":"Public API","title":"GeoBasics.get_lat","text":"get_lat(p)\n\nExtracts the latitude from a point p and returns it expressed in degrees and without a unit.\n\nnote: Note\nThis function exploits GeoPlottingHelpers.to_row_lonlat internally so any object that has a valid method for to_row_lonlat will work as input.\n\nSee also get_lon.\n\n\n\n\n\n","category":"function"},{"location":"public/#GeoBasics.get_lon","page":"Public API","title":"GeoBasics.get_lon","text":"get_lon(p)\n\nExtracts the longitude from a point p and returns it expressed in degrees and without a unit.\n\nnote: Note\nThis function exploits GeoPlottingHelpers.to_row_lonlat internally so any object that has a valid method for to_row_lonlat will work as input.\n\nSee also get_lat.\n\n\n\n\n\n","category":"function"},{"location":"public/#Base.keepat!-Tuple{GeoBorders, Any}","page":"Public API","title":"Base.keepat!","text":"Base.keepat!(gb::GeoBorders, inds)\n\nKeep the polyareas and bboxes (for both CRSs) associated to the provided indices inds from the GeoBorders object.\n\nnote: Note\nThis is simply calling Base.keepat! with provided indices to all the arrays of polyareas/bboxes contained in GeoBorders. It is just intended as an easier and more consistent way to remove specific elements from GeoBorders instances, as removal have to be done from all the underlying arrays at the same time.\n\n\n\n\n\n","category":"method"},{"location":"public/#Base.deleteat!-Tuple{GeoBorders, Any}","page":"Public API","title":"Base.deleteat!","text":"Base.deleteat!(gb::GeoBorders, inds)\n\nRemove the polyareas and bboxes (for both CRSs) associated to the provided indices inds from the GeoBorders object.\n\nnote: Note\nThis is simply calling Base.deleteat! with provided indices to all the arrays of polyareas/bboxes contained in GeoBorders. It is just intended as an easier and more consistent way to remove specific elements from GeoBorders instances, as removal have to be done from all the underlying arrays at the same time.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal/","page":"Internal API","title":"Internal API","text":"The following functions are neither public nor exported and may be subject to change in future non-breaking releases.","category":"page"},{"location":"internal/#Types","page":"Internal API","title":"Types","text":"","category":"section"},{"location":"internal/#GeoBasics.VALID_CRS","page":"Internal API","title":"GeoBasics.VALID_CRS","text":"const VALID_CRS = Union{Type{LatLon}, Type{Cartesian}}\n\nUnion type representing the valid CRS types for the public API of this package. \n\n\n\n\n\n","category":"type"},{"location":"internal/#GeoBasics.VALID_DOMAINS","page":"Internal API","title":"GeoBasics.VALID_DOMAINS","text":"const VALID_DOMAINS{T} = Union{FastInDomainUnion{T}, FastInSubDomain{T}}\n\nThis is the union representing all domains for which fast point inclusion algorithm is defined. It contains both FastInDomain defined in this package as well as a plain GeometrySet of FastInGeometry objects as well as SubDomains of either of the previous domains\n\n\n\n\n\n","category":"type"},{"location":"internal/#Helpers","page":"Internal API","title":"Helpers","text":"","category":"section"},{"location":"internal/#GeoBasics.in_exit_early","page":"Internal API","title":"GeoBasics.in_exit_early","text":"in_exit_early(p, geom)\n\nFunction that checks if a point is contained within the geometry geom using the fast point inclusion algorithm that relies on availability geom has valid methods for polyareas and bboxes.\n\nIt is expected that the input geom also has a valid method for BasicTypes.valuetype in order to extract the T type parameter to convert p to a valid cartesian point.\n\nnote: Note\nThis method is basically pre-filtering points by checking inclusion in the bounding box which is significantly faster than checking for the polyarea itself, especially if the polyareas is composed by a large number of points.\n\nSee also polyareas, bboxes, FastInGeometry, geoborders, GeoBorders.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GeoBasics.cartesian_geometry","page":"Internal API","title":"GeoBasics.cartesian_geometry","text":"cartesian_geometry(T::Type{<:AbstractFloat}, geom)\ncartesian_geometry(T::Type{<:AbstractFloat})\ncartesian_geometry(geom)\n\nConvert geometries from LatLon to Cartesian coordinate systems, optionally changing the underlying machine type of the points to T\n\nThe second method simply returns Base.Fix1(cartesian_geometry, T).\n\nThe third method, will try to extract the machine precision from geom and translates to cartesian_geometry(BasicTypes.valuetype(geom), geom).\n\nArguments\n\nT::Type{<:AbstractFloat}: The desired machine type of the points in the output geometry. If not provided, it will default to the machine type of the input geometry.\ngeom: The geometry to convert, which can be an arbitrary Geometry either in LatLon{WGS84Latest} or Cartesian2D{WGS84Latest} coordinates.\n\nReturns\n\nThe converted geometry, with points of type POINT_CART{T}.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GeoBasics.latlon_geometry","page":"Internal API","title":"GeoBasics.latlon_geometry","text":"latlon_geometry(T::Type{<:AbstractFloat}, geom)\nlatlon_geometry(T::Type{<:AbstractFloat})\nlatlon_geometry(geom)\n\nConvert geometries from Cartesian to LatLon coordinate systems, optionally changing the underlying machine type of the points to T\n\nThe second method simply returns Base.Fix1(latlon_geometry, T).\n\nThe third method, will try to extract the machine precision from geom and translates to latlon_geometry(BasicTypes.valuetype(geom), geom).\n\nArguments\n\nT::Type{<:AbstractFloat}: The desired machine type of the points in the output geometry. If not provided, it will default to the machine type of the input geometry.\ngeom: The geometry to convert, which can be an arbitrary Geometry either in LatLon{WGS84Latest} or Cartesian2D{WGS84Latest} coordinates.\n\nReturns\n\nThe converted geometry, with points of type POINT_LATLON{T}.\n\n\n\n\n\n","category":"function"},{"location":"#GeoBasics","page":"Home","title":"GeoBasics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides fundamental building blocks for geographic operations, specifically designed for downstream packages in the JuliaSatcomFramework ecosystem. It builds open the JuliaEarth ecosystem and specifically heavily relies on Meshes.jl and CoordRefSystems.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It mainly addresses two desired functionalities in our downstream packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simplifying a way to create custom types representing regions/geometries which have an optimized algorithm for check point inclusion (within the region)\nThis is achieved by subtyping the FastInGeometry abstract type and implementing its limited interface\nAvoiding issues with regions created from polygons that might cross the antimeridian (the line where longitude is ±180°). \nThis is handled in the constructor of GeoBorders, the only concrete type implementing the FastInGeometry interface exposed by this package. \nThe algorithm to fix antimeridian crossing is based on the algorithm implemented in the python package antimeridian that also provides a simplified explanation of the algorithm in its documentation.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Point-inclusion-algorithm","page":"Tutorial","title":"Point inclusion algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package was born from the need of ensuring a simple way of optimizing the performance of checking whether a point on the Earth's surface is located within a given region (e.g. a country, a satellite beam, or any other area that can be represented by a polygon in latitude/longitude coordinates).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We need to define multiple types of such regions in our downstream packages (e.g. CountriesBorders.jl) and we want to minimize code duplication as much as possible.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The traditional p in region is well defined in Meshes.jl but is suboptimal in terms of performance when one wants to check a lot of points (e.g. thousands) over a domain spanning multiple polygons (e.g. the domain of all polygons associated to all countries). The complexity of checking for point inclusion in a polygon increases with the number of points in the polygon, and when you have lots of points and lots of polygons, most of your point/polygon pair will return false.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The approach to speed up computations taken in this package is to create custom geometries that store not only the polyareas but also the bounding boxes (i.e. a Box from Meshes.jl) associated to each polyarea.  The modified inclusion algorithm then simply prefilters point/polygon pairs by checking first inclusion in the bounding box (which is extremely fast) and falling back to checkin inclusion in the polygon only if p in bbox is true. This has shown to provide speed ups of 20x-40x in tests when implemented for the CountriesBorders.jl downstream package (see this PR)","category":"page"},{"location":"tutorial/#FastInGeometry-Interface","page":"Tutorial","title":"FastInGeometry Interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To simplify exploiting this fast algorithm for custom geometries defined in downstream packages, this package defines an interface that is adhered to when a type satisfies the three conditions below:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It subtypes the FastInGeometry abstract type defined and exported by this package\nIt has a valid method for the interface function polyareas returning an iterable of PolyAreas.\nIt has a valid method for the interface function bboxes returning an iterable of Boxs","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In reality, the 2nd and 3rd conditions can also be met by simply containing a field which subtypes GeoBorders (more details in the next section) or defining a custom method for the interface function geoborders that returns an instance of type GeoBorders.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, see the following code snippet defining a simple geometry that satisfies the FastInGeometry interface by resorting to the simplest approach of having a field subtyping GeoBorders","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeoBasics\n\n# Define a custom type which subtypes \nstruct SimpleGeometry <: FastInGeometry{Float64}\n    name::String\n    borders::GeoBorders{Float64}\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Cartesian CRS\nThe custom geometries adhering to the FastInGeometry interface are expected to store the relevant bboxes and polyareas both in the LatLon and Cartesian2D CRS. This is because many of Meshes advanced methods are better defined for Cartesian2D and so we want to have an easier access to the geometries also in this CRS. The conversion between LatLon and Cartesian2D corresponds to an Equirectangular projection where 1° of latitude/longitude is mapped to 1m in the projected space. This is also equivalent to the transformation achived by calling the Meshes.flat function to a point in LatLon CRS. ","category":"page"},{"location":"tutorial/#GeoBorders","page":"Tutorial","title":"GeoBorders","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package defines a single concrete subtype satisfying the FastInGeometry interface with the GeoBorders type. This is intended to represent the borders of arbitrary regions, and provides an easy way for custom regions to adhere to the FastInGeometry interface (as explained above).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Additionally, when provided with geometries that are plain Multi, PolyArea or Box from Meshes (and not other geometries satysfiying the FastInGeometry interface), the constructor for GeoBorders automatically tries fixing issues with polygons crossing the antimeridian line. It does so by implementing the algorithm of the antimeridian python library that also provides a simplified explanation of the algorithm in its documentation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To show the problem of with polygons crossing the antimeridian, consider the following complex polygon that contains holes and crosses the antimeridian multiple times","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GeoBasics\nusing GeoBasics.Meshes\nusing GeoBasics.GeoPlottingHelpers\nusing PlotlyBase\nusing PlotlyDocumenter\n\ncomplex_s_poly = let\n    f = to_cartesian_point\n    outer = map(f, [ # Exterior part of the polygon, crossing the antimeridian multiple times\n        (160,30),\n        (-160,30),\n        (-160,0),\n        (170, 0),\n        (170, -10),\n        (-160, -10),\n        (-160, -20),\n        (160, -20),\n        (160, 10),\n        (-170, 10),\n        (-170, 20),\n        (160, 20),\n    ]) |> Ring\n    inner_west = map(f, [ # Hole in the western hemisphere, in the lower right of the polygon\n        (-162, -12),\n        (-162, -18),\n        (-168, -18), \n        (-168, -12)\n    ]) |> Ring\n    inner_east = map(f, [ # Hole in the eastern hemisphere, in the upper left of the polygon\n        (162, 22),\n        (162, 28),\n        (168, 28), \n        (168, 22)\n    ]) |> Ring\n    inner_both = map(f, [ # Hole crossing the antimeridian, in the middle of the polygon\n        (170, 2),\n        (170, 8),\n        (-170, 8), \n        (-170, 2)\n    ]) |> Ring\n    PolyArea([outer, inner_west, inner_east, inner_both])\nend\n\nplt = with_settings(:OVERSAMPLE_LINES => :SHORT) do # This makes sure that the plot uses the shortest line between points\n    data = geo_plotly_trace(complex_s_poly)\n    Plot(data, Layout(;\n      geo = attr(; \n        center_lon = 180,\n        lonaxis_range = [0, 360]\n      )\n    ))\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In reality, the polygon looks fine because we forced the plot to use shortest line between points for plotting (thus crossing the antimeridian). The actual polygon defined with those coordinates represents instead the following degenerate region:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line\n    data = geo_plotly_trace(complex_s_poly)\n    Plot(data)\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"which can also be verified by checking point inclusion of one point that shouldn't be inside but is, and of one that should be in but isn't:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# We use cartesian point as point inclusion in LatLon is not always defined in Meshes\nshould_not = to_cartesian_point(LatLon(25, 0)) # This is in africa and shouldn't be in the intended polygon\nshould_be = to_cartesian_point(LatLon(25, 180)) # This is in the ocean inside the polygon and outside it's holes\n\nmap(in(complex_s_poly), (;should_be, should_not))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By feeding this polygon into the constructor of GeoBorders, the antimeridian crossin is handled by splitting the input polygon into 4 subpolygons whenever a crossing of the antimeridian is encountered:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"gb = GeoBorders(complex_s_poly)\nplt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line, showing that GeoBorders handle this correctly\n    data = geo_plotly_trace(gb)\n    Plot(data, Layout(;\n      geo = attr(; \n        center_lon = 180,\n        lonaxis_range = [0, 360]\n      )\n    ))\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And checking again for point inclusion we find the expected behavior (including a point in the hole not being considered inside).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"inside_hole = LatLon(25, 165) # Notice that this does not need to be a Point\n\nmap(in(gb), (; should_be, should_not, inside_hole))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As seen from the last example, there is one additional advantage to satisfying the FastInGeometry interface. Inclusion in a FastInRegion does not need to use points which are of Point type with the exact same CRS as the geometry (as in plain Meshes) but can be:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a Point with either LatLon{WGS84Latest} or Cartesian2D{WGS84Latest} CRS,\na plain LatLon{WGS84Latest} coordinate.","category":"page"},{"location":"tutorial/#Override-antimeridian-fix","page":"Tutorial","title":"Override antimeridian fix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The procedure in the GeoBorders constructor that fixes the antimeridian crossing decides if there is one by simply checking if any segment of a polygon spans more than 180° degrees of longitude.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In some cases, this has the unintended consequence of modifying the intended polygon. Consider for example a rectangular polygon going from -100 to +100 longitude and from -20 to + 20 latitude. Creating a GeoBorders with this input polygon will uncorrectly split it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"large_rectangle = let\n  f = to_latlon_point(Float64)\n  PolyArea(map(f, [\n    LatLon(-20, -100),\n    LatLon(-20, 100),\n    LatLon(20, 100),\n    LatLon(20, -100),\n  ]))\nend\n\nplt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line\n    data = geo_plotly_trace(GeoBorders(large_rectangle))\n    Plot(data)\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In these cases, it is possible to override this behavior by using the fix_antimeridian_crossing keyword argument:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plt = with_settings(:OVERSAMPLE_LINES => :NORMAL) do # Actually draw lines from endpoints without using shorted line\n    data = geo_plotly_trace(GeoBorders(large_rectangle; fix_antimeridian_crossing = false))\n    Plot(data)\nend\nto_documenter(plt) # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nThe fix_antimeridian_crossing keyword argument is only respected for input geometries which are not already implementing the FastInGeometry interface. As mentioned in the polyareas docstrings, the polygons of FastInGeometry are already assumed to be fixed and so will always be kept as defined within the geometry.","category":"page"},{"location":"tutorial/#FastInDomain-Interface","page":"Tutorial","title":"FastInDomain Interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As alternative to subtyping FastInGeometry, custom types can also participate to the fast inclusion algorithms if they subtype FastInDomain. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this case, the custom subtype must represent a domain containing geometries implementing the FastInGeometry interface and must implement have valid methods for the following two functions from Meshes.jl:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Meshes.nelements(custom_domain): This should return the number of geometries within the domain\nMeshes.element(custom_domain, ind): This should return the ind-th geometry from the domain","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See an example implementation of a custom domain with elements of a custom geometry satisfying the interface","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct SimpleGeometry <: FastInGeometry{Float64}\n    name::String\n    borders::GeoBorders{Float64}\nend\n\nfunction SimpleGeometry(geoms; name = \"SimpleGeometry\")\n    borders = GeoBorders{Float64}(geoms)\n    return SimpleGeometry(name, borders)\nend\n\nstruct SimpleDomain <: FastInDomain{Float64}\n    name::String\n    geoms::Vector{SimpleGeometry}\nend\n\nMeshes.nelements(sd::SimpleDomain) = length(sd.geoms)\nMeshes.element(sd::SimpleDomain, ind::Int) = sd.geoms[ind]","category":"page"}]
}
